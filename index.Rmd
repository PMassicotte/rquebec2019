---
title: "Programmation fonctionelle avec R"
subtitle: "R à Québec 2019"
author: "Philippe Massicotte"
date: "2019-05-14"
output:
  xaringan::moon_reader:
    yolo: false
    lib_dir: libs
    css: [default, default, robot-fonts, styles.css]
    nature:
      highlightStyle: github
      highlightLines: true
      highlightSpans: true
      countIncrementalSlides: false
      # beforeInit: "https://platform.twitter.com/widgets.js"
      ratio: '16:9'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, dev = "svg", message = FALSE)
options(htmltools.dir.version = FALSE)
# names(xaringan:::list_css())

library(tidyverse)
library(extrafont)

## Set default ggplot2 font size and font familly

loadfonts(quiet = TRUE)
theme_set(theme_bw(base_size = 12, base_family = "IBM Plex Sans"))

htmltools::tagList(rmarkdown::html_dependency_font_awesome())
```

<br>

<center><img src="images/myname.png" alt="drawing" width="400"/></center>

<p align="left">

<b>Assistant de recherche à Takuvik (télédétection, modélisation, data science)</b><br>

- Utilise R depuis plus de 6 ans<br>
- Auteur de 3 libraries sur CRAN<br>
- Blog R: www.pmassicotte.com<br>

<br>

<i class="fab fa-github"></i> https://github.com/PMassicotte <br>
<i class="far fa-envelope"></i> philippe.massicotte@takuvik.ulaval.ca <br>
<i class="fab fa-twitter"></i> @philmassicotte

</p>

---

class: inverse, center, middle

# Plan de la formation

---

## Plan de la formation

1. Introduction et mise en contexte
  * Les dangers de la duplication du code

2. La programmation fonctionnelle
  * Opérations sur des vecteurs
  * Opérations sur des *data frame*

- Présentation disponible à cette adresse: **http://www.pmassicotte.com/rquebec2019/**

- Théorie + exercices après chaque concept.

- Votre participation!

---

## *Data science*

Dans plusieurs domaines, les données sont produites très rapidement à des échelles spatiales et temporelles élevées:

- Environnement: météo, capteurs automatisés (salinité)
- Finances:
- Assurances:
- Transports: géolocations, 
- etc.

La manipulation de ces données demande ...

---

## *Data science*

<figure>
<center>
<img src="http://i2.wp.com/sciencereview.berkeley.edu/wp-content/uploads/2014/04/spring_2014_azam_01.jpg" height = "350">
<figcaption>Source: http://berkeleysciencereview.com/article/first-rule-data-science</figcaption>
</center>
</figure>

---

## *Data science*

Il est important d'apprendre et de mettre en pratique les outils essentiels pour capturer, manipuler et partager des données.

- Pourquoi est-ce important?

**Le 80/20 du *data science***

> Most data scientists spend only 20 percent of their time on actual data analysis and 80 percent of their time finding, cleaning, and reorganizing huge amounts of data, which is an inefficient data strategy (https://bit.ly/2wjB8IB).

**La manipulation de données est une tâche répétitive et propice aux erreurs!**

---

class: inverse, center, middle

# Exemples de code répétitif

---

## Répéter la même opération sur plusieurs colonnes

On veut normaliser chaque colonne de `df` de manière à ce que les données varient entre 0 et 1.

```{r}
set.seed(1234)

# Générer des données, 4 colonnes avec 10 observations
df <- data.frame(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

df

```

---

## Répéter la même opération sur plusieurs colonnes

On veut normaliser chaque colonne de `df` de manière à ce que les données varient entre 0 et 1.

$$
\frac{x - \text{min}(x)}{\text{max}(x) - \text{min}(x)}
$$

```{r}
# Générer un vecteur de 10 nombres
set.seed(1234)
x <- sample(10)
x

# Normaliser les données
(x - min(x)) / (max(x) - min(x))

```

---

## Répéter la même opération sur plusieurs colonnes

- On veut normaliser chaque colonne de `df` de manière à ce que les données varient entre 0 et 1.

- On effectu la même opération à toutes les colonnes de `df`.

```{r}
# Normaliser la colonne a
df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))

# Normaliser la colonne b
df$b <- (df$b - min(df$b, na.rm = TRUE)) /
  (max(df$b, na.rm = TRUE) - min(df$b, na.rm = TRUE))

# Normaliser la colonne c
df$c <- (df$c - min(df$a, na.rm = TRUE)) /
  (max(df$c, na.rm = TRUE) - min(df$a, na.rm = TRUE))

# Normaliser la colonne d
df$d <- (df$d - min(df$d, na.rm = TRUE)) /
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))

```

---

## Répéter la même opération sur plusieurs colonnes

Chaque colonne (vecteur) est maintenant entre 0-1.

```{r}
df
```

---

## Répéter la même opération sur plusieurs colonnes

Quel est le problème?

```{r, eval=FALSE}
df$a <- (df$a - min(df$a, na.rm = TRUE)) /
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) /
  (max(df$b, na.rm = TRUE) - min(df$b, na.rm = TRUE))
df$c <- (df$c - min(df$a, na.rm = TRUE)) /
  (max(df$c, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$d <- (df$d - min(df$d, na.rm = TRUE)) /
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))
```

--

Erreur de copié/collé!!!

```{r, eval=FALSE}
df$a <- (df$a - min(df$a, na.rm = TRUE)) /
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) /
  (max(df$b, na.rm = TRUE) - min(df$b, na.rm = TRUE))
df$c <- (df$c - min(df$c, na.rm = TRUE)) /
  {{(max(df$c, na.rm = TRUE) - min(df$a, na.rm = TRUE))}}
df$d <- (df$d - min(df$d, na.rm = TRUE)) /
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))
```

---

## Nombre raisonable de répétitions

- DRY: **D**on't **R**epeate **Y**ourself

- Il est souvent dit que si vous avez 3 copies du même code, **il est temps d'écrire une fonction**.

<br>
<center>
<a href="https://imgflip.com/i/2y8ds5"><img src="https://i.imgflip.com/2y8ds5.jpg" height = "300", title="made at imgflip.com"/></a>
</center>

---

## Répéter la même opération sur plusieurs colonnes

Une première amélioration: **utiliser une fonction**.

--

Étudier la formule de base

```{r, eval=FALSE}
(`df$d` - min(`df$d`, na.rm = TRUE)) / 
  (max(`df$d`, na.rm = TRUE) - min(`df$d`, na.rm = TRUE))
```

--

Paramétriser le code -> remplacer les variables par des arguments

```{r, eval=FALSE}
res <- (`x` - min(`x`, na.rm = TRUE)) / 
  (max(`x`, na.rm = TRUE) - min(`x`, na.rm = TRUE))
```

--

Écrire une fonction

```{r}
# Fonction qui prend un vecteur numerique "x" et qui scale les valeurs entre 0-1
scale_vector <- function(x) {
  res <- (x - min(x, na.rm = TRUE)) / 
    (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
  
  return(res)
}
```

---

## Tester notre fonction

```{r}
# Vecteur numérique
v <- c(0, 1, 45, 98, -5)
v

scale_vector(v)
```

--

<center>
<image src="https://media.giphy.com/media/8JW82ndaYfmNoYAekM/giphy.gif" height="300" frameBorder="0" class="giphy-embed" allowFullScreen></image>
</center>

---

## Utiliser la fonction sur le *data frame*

Maintenant que la fonction `scale_vector()` fonctionne, utilisons-là sur chacune des colonnes du *data frame*.

```{r}
df$a <- scale_vector(df$a)
df$b <- scale_vector(df$b)
df$c <- scale_vector(df$b)
df$d <- scale_vector(df$d)

df
```

---

## Deja mieux!

L'utilisation de la fonction `scale_vector()` rend le code beaucoup plus simple.

```{r, eval=FALSE}
df$a <- scale_vector(df$a)
df$b <- scale_vector(df$b)
df$c <- scale_vector(df$b)
df$d <- scale_vector(df$d)
```

VS

```{r, eval=FALSE}
df$a <- (df$a - min(df$a, na.rm = TRUE)) /
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) /
  (max(df$b, na.rm = TRUE) - min(df$b, na.rm = TRUE))
df$c <- (df$c - min(df$c, na.rm = TRUE)) /
  (max(df$c, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$d <- (df$d - min(df$d, na.rm = TRUE)) /
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))
```

---

## Utiliser la fonction sur le *data frame*

Fonctionne très bien, mais il y a 4 répétitions.

```{r, eval=FALSE}
df$a <- scale_vector(df$a)
df$b <- scale_vector(df$b)
df$c <- scale_vector(df$b)
df$d <- scale_vector(df$d)
```

--

Toujours la possibilité de se tromper!

.pull-left[

```{r, eval=FALSE}
df$a <- scale_vector(df$a)
df$b <- scale_vector(df$b)
{{df$c <- scale_vector(df$b)}}
df$d <- scale_vector(df$d)
```
]

.pull-right[
<image src="https://media.giphy.com/media/l1KVaj5UcbHwrBMqI/giphy.gif" height="200"</image>
]

---

## Répéter la même opération sur plusieurs colonnes

Une deuxième amélioration: pourquoi ne pas **utiliser une boucle** qui permettrait de répéter l'opération plusieurs fois?

<center>
<image src="https://media.giphy.com/media/7XuPYJXaF1CBAmbwQQ/giphy.gif" width="480" height="360" frameBorder="0" class="giphy-embed" allowFullScreen></image>
</center>

---

class: inverse

## Exercice

.full-width[.content-box-gray[Écrivez une boucle qui permet de normaliser toutes les colonnes de `df`. Au lieu de `scale_vector()`, vous pouvez utiliser la fonction `scale(x, center = FALSE, scale = TRUE)` fournit avec R.]]

```{r}

scale_vector <- function(x) {
  res <- (x - min(x, na.rm = TRUE)) / 
    (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
  
  return(res)
}

set.seed(1234)

# Générer des données, 4 colonnes avec 10 observations
df <- data.frame(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

```

---

## Problèmes potentiels des boucles



--

Il faut bien gérer les index utilisées.

```{r, eval=FALSE}
for (i in 1:ncol(df)) {
  df2[, i] <- scale_vector(df[, i])

  ... # Code super compliqué avec plusieurs lignes

  {{i <- i / pi}} # Changer sans le vouloir la valeur de l'index
}
```

--

Propice aux erreurs lorsque plusieurs boucles sont imbriquées.

```{r, eval=FALSE}

for(i in 1:ncol(df)) {
  
  for(j = 1:ncol(df)) {
    {{df2[j, i] <- df[i, j]}}
  }
  
}
```

---

class: inverse, center, middle

# Notes sur les boucles

*They are not the evil you might think*

---

## Rapidité des boucles

Contrairement à l'idée reçue, les boucles en R ne sont pas nécessairement lentes. La plupart du temps, la lenteur des boucles est liée au fait que la variable qui reçoit le résultat n'est pas initialisée.

Dans l'exemple suivant, on veut créer une boucle qui créer un vecteur de 1000 éléments avec les valeurs de 1 à 1000.

.pull-left[

**Boucle sans initialisation**

```{r}
n <- 1000

f_slow <- function(n) {
  {{v <- NULL}}
  for (i in 1:n) 
    v <- c(v, i)
  
  return(v)
}

```
]

.pull-right[

**Boucle avec initialisation**

```{r}
n <- 1000

f_fast <- function(n) {
  {{v <- vector(mode = "numeric", length = n)}}
  for (i in 1:n) 
    v[i] <- i
  
  return(v)
}
```

]

---

## Rapidité des boucles

Les boucles ne sont pas foncièrement lentes!

```{r, message=FALSE, echo=TRUE, fig.height=4, fig.align="center"}
# Calculer le temps d'exécution des deux fonctions/boucles
timing <- microbenchmark::microbenchmark(f_slow(n), f_fast(n))
autoplot(timing)
```


---

## Les boucles

Les boucles c'est bien, mais c'est encore mieux sans!

**FIGURE HERE**

---

class: inverse, center, middle

## La programmation fonctionnelle

<img src="https://adv-r.hadley.nz/cover.png" height="400">


Advanced R (Chapman & Hall/CRC The R Series)

---

## La programmation fonctionnelle

> La programmation fonctionnelle est un paradigme de programmation de type déclaratif qui considère le calcul en tant qu'évaluation de fonctions mathématiques. (Wikipedia)

- La principale caractéristique de la programmation fonctionnelle est **que des fonctions sont passées en paramètre** à d'autres fonctions.

- L'idée de passer d'une fonction à une autre est une idée extrêmement puissante et c'est l'un des comportements qui font de R un langage de programmation fonctionnel.

- Comparé à l'utilisation d'une boucle, l'accent est mis sur l'opération effectuée (*i.e. la fonction à appliquer*) et non sur la mécanique nécessaire pour naviguer au travers des éléments et sur comment stocker le résultat.

- Il y a de fortes chances que vous ayez déjà utilisé la fonction `lapply()`. La fonction `lapply()` est appelé **un fonctionnel**, car elle utilise une fonction comme paramètre.

---

## Avantages de la programmation fonctionnelle

- Le code est plus compacte (plus facile à lire et comprendre).

- Plus facile à gérer et modifier: lorsque vous créez une fonction pour une tâche répétée, il est facile de modifier cette fonction. Ensuite, chaque emplacement de votre code où la même tâche est effectuée est automatiquement mis à jour.

```{r, eval=FALSE}
scale_vector <- function(x) {
  
  res <- (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
  
  return(res)
}
```

- Modularité: si vous écrivez une fonction pour des tâches individuelles spécifiques, vous pouvez les utiliser plusieurs fois. Une fonction que vous écrivez pour un script peut même être réutilisée dans d'autres scripts!

<small>https://www.earthdatascience.org/courses/earth-analytics/automate-science-workflows/write-efficient-code-for-science-r/</small>

---

## *purrr*

La librairie `purrr` offre plusieurs outils de programmation fonctionnelle.

<center><img src="https://purrr.tidyverse.org/logo.png" width="200"/></center>

`purrr` n'est pas installé par défaut. L'installation de `tidyverse` inclut la librairie `purrr`.

```{r, eval=FALSE}
install.packages("tidyverse")
library(tidyverse)
```

---

class: inverse, center, middle

# Tidyverse

## Une série d'outils pour la manipulation de données

<center>
<img src="https://tidyverse.tidyverse.org/logo.png" width="200"/>
</center>

<center>
<img src="https://dplyr.tidyverse.org/logo.png" width="120"/> <img src="https://tidyr.tidyverse.org/logo.png" width="120"/> <img src="https://readr.tidyverse.org/logo.png" width="120"/> <img src="https://readxl.tidyverse.org/logo.png" width="120"/> <img src="https://ggplot2.tidyverse.org/logo.png" width="120"/><img src="https://stringr.tidyverse.org/logo.png" width="120"/><img src="https://lubridate.tidyverse.org/logo.png" width="120"/><img src="https://purrr.tidyverse.org/logo.png" width="120"/>
</center>

---

## La fonction `map()`

La fonction `map()` de la librairie `purrr` permet de **d'appliquer** une fonction `f()` à une liste d'éléments.

<br>

<center>
<img src="https://d33wubrfki0l68.cloudfront.net/f0494d020aa517ae7b1011cea4c4a9f21702df8b/2577b/diagrams/functionals/map.png" height="250"/>
</center>

<small>https://adv-r.hadley.nz/functionals.html#map</small>

---

## La fonction `map()`

Dans ce premier example, on veux ajouter la valeur de 1 à tous les éléments d'un vecteur numérique.

```{r}
# Créer une fonction "f" qui prend un nombre et lui ajoute la valeur de 1.
f <- function(x) {
  x + 1
}

# "Appliquer" la fonction "f" au vecteur 1, 2, 3
map(c(1, 2, 3), f)
```

<br>
.content-box-blue[Il est important de prendre note que la fonction `map()` retourne toujours une liste d'éléments.]

---

## La fonction `map()`

On veut connaître la classe de chaque colonne du *data frame* `mtcars`.

```{r}
head(mtcars)
```

---

## La fonction `map()`

Il est tentant de faire du copié/collé:

```{r}
class(mtcars$mpg)
class(mtcars$cyl)
class(mtcars$disp)
```

---

## La fonction `map()`

Ou bien de faire une boucle:

```{r}
# Vecteur pour le résultat
res <- vector(mode = "character", length = ncol(mtcars))

# Faire une boucle sur toutes les colonnes de mtcars
for(i in 1:ncol(mtcars)) {
  res[i] <- class(mtcars[, i])
}

res
```

---

class: inverse, center, middle

## Exercice

.full-width[.content-box-gray[Utilisez la fonction `map()` pour extraire la classe de chacune des colonnes de `mtcars`.]]

---

## Les fonctions anonymes

Revenons à notre exemple qui ajoute la valeur 1 à un vecteur.

```{r, eval=FALSE}
# Créer une fonction "f" qui prend un nombre et lui ajoute la valeur de 1.
f <- function(x) {
  x + 1
}

# "Appliquer" la fonction "f" au vecteur 1, 2, 3
map(1:3, f)
```

- Création d'une fonction `f()` très simple.
- Il est possible d'utiliser des **fonctions anonymes** quand ça ne vaut pas la peine de lui donner un nom.

---

## Les fonctions anonymes et formules

L'exemple précédent peut se ré-écrie en utilisant une fonction anonyme. Avec cette approche, nous n'avons pas besoin de fournir un nom de fonction.

```{r}
map(1:3, function(x) x + 1)
```

Nottez que l'utilisations de `map()` dans ce cas-ci n'est pas très utile. On pourrait évidement reproduire le résultat en utilisant:

```{r}
(1:3) + 1
```

---

## Les fonctions anonymes et formules

On peut également utiliser l'approche par formule conjointement avec `~`. Ici on fait référence au paramètre en utilisant la notation `~.x`. 

```{r}
map(1:3, ~.x + 1)
```

```{r}
map(1:3, ~log(.x))
```

---

## Les fonctions anonymes et formules: un résumé

Il y a trois façons différentes d'utiliser des fonctions anonymes avec `purrr`.

```{r, eval=FALSE}
x <- 1:3

map(x, function(x) log(x, base = 2))

map(x, log, base = 2)

map(x, ~log(.x, base = 2))
```


---

class: inverse

## Exercice

```{r, echo=FALSE, warning=FALSE, message=FALSE}
df <- read_csv2("https://perso.telecom-paristech.fr/eagan/class/igr204/data/cars.csv")

df <- df[-1, ]

res <- map(df, parse_guess) %>% 
  as_tibble() %>% 
  janitor::clean_names()

# One NA in the data

res$mpg[10] <- NA

write_csv(res, "data/clean/cars.csv")

```

.full-width[.content-box-gray[Calculez la moyenne de chacune des colonnes de ce jeux de données en utilisant une fonction anonyme.]]

```{r, message=FALSE}
df <- read_csv("data/clean/cars.csv")
head(df, 3)

# Sélectionner seulement les colonnes numériques
df <- select_if(df, is.numeric)
```
<small>Données: https://perso.telecom-paristech.fr/eagan/class/igr204</small>

```{r, echo=FALSE, eval=FALSE}
map(df, function(y) mean(y))
```

---

## Utilisation des paramètres

- Jusqu'à maintenant, nous avons invoqué l'appel de fonctions sans l'utilisation de paramètres.

- Il est possible de spécifier les valeurs de paramètres à fournir à la fonction en utilisant des paramètres nommées de la manière suivante: 
```{r, eval=FALSE}
map(list, function, param1 = xxx, param2 = yyy, param3 = zzz)
```

Exemple avec les données *cars*. On veut calculer la moyenne de chacune des colonnes numériques.

```{r, message=FALSE}
# library(tidyverse)
df <- read_csv("data/clean/cars.csv")
df <- select_if(df, is.numeric)
```

La fonction `mean()` a un paramètre `na.rm = FALSE` qui permet de spécifier si les `NA` doivent être incluent dans le calcul.

---

## Utilisation des paramètres

.pull-left[

```{r}
map(df, mean) 
```
]

.pull-right[
```{r}
{{map(df, mean, na.rm = TRUE)}}
```
]

---

## Les variantes de `map()`

Il y a plusieurs variantes de `map_*()` qui permettent **d'être explicite sur la classe retournée par la fonction**.

<br><br>

|   Fonction   |      Description      |
| ------------ | --------------------- |
| `map_dbl()`  | Vecteur de doubles    |
| `map_int()`  | Vecteur d'entiers     |
| `map_char()` | Vecteur de caracètres |
| `map_lgl()`  | Vecteur de booléens   |
| `map_df()`   | Liste de *data frame* |

---

## Les variantes de `map()`

Par example, on sait que la fonction `mean()` retourne une valeur numérique. Dans ce cas, on peut utiliser la fonction `map_dbl()` pour calculer la valeur moyenne de chacune des colonnes de `mtcars`.

```{r}
# Appliquer la fonction "mean" à chacune des colonnes de mtcars
map_dbl(mtcars, mean) 
```

---

class: inverse

## Exercice (1/2)

.full-width[.content-box-gray[Séparez le jeux de données `mtcars` en fonction du nombre de cylindre. Utilisez une variante de la fonction `map_*()` pour connâitre le nombre d'observation de chaque groupe.]]

```{r}
res <- split(mtcars, mtcars$cyl)
```

---

class: inverse

## Exercice (2/2)

.full-width[.content-box-gray[Séparez le jeux de données `mtcars` en fonction du nombre de cylindre. Pour chacun des groupes, faire un modèle linéaire `mpg` en fonction de `wt` (`lm(mpg ~ wt)`). Écrivez une fonction `fit()` pour faire le modèle linéaire.]]

```{r, eval=FALSE}
res <- split(mtcars, mtcars$cyl)

fit <- function(...) {
  ...
}

map(..., ...)

```

Interdiction de faire...

```{r, eval=FALSE}
mod1 <- lm(mpg ~ wt, data = subset(mtcars, cyl == 4))
mod2 <- lm(mpg ~ wt, data = subset(mtcars, cyl == 6))
mod3 <- lm(mpg ~ wt, data = subset(mtcars, cyl == 8))
```



```{r, echo=FALSE, eval=FALSE}

fit <- function(df) {
  
  lm(mpg ~ wt, data = df)
  
}

map(res, fit)

```

```{r, echo=FALSE, eval=FALSE}
# Version anonyme
map(res, function(df) lm(mpg ~ wt, data = df))
```

```{r, echo=FALSE, eval=FALSE}
# Version avec formule
map(res, ~lm(mpg ~ wt, data = .))
```

---

## Map sur plusieurs vecteurs/listes

Jusqu'ici, nous avons *mappé* avec une seule entrée (un seul vecteur ou une seule liste). Si vous avez plusieurs entrées, vous devez **parcourir en parallèle**. Pour ce faire, nous utiliserons les fonctions `map2()` et `pmap()`.

La fonction `map2()` permet de parcourrir en parallèle deux **vecteurs/listes**. L'utilisation de base de `map2()` est similaire à `map()`.

```{r, eval=FALSE}
map2(.x, .y, .f, ...)

map2(INPUT_ONE, INPUT_TWO, FUNCTION_TO_APPLY, OPTIONAL_ARGUMENTS)
```

---

## Map sur plusieurs vecteurs/listes

Imaginons que nous voulions générer trois vecteurs de valeurs aléatoires à l'aide de la fonction `rnorm()`. Pour chaque génération, nous voulons spécifier une moyenne différente.

.pull-left[
```{r}
# Vecteur de moyennes
mu <- c(4, -1, 3)

map(mu, rnorm, n = 4)
```
]

.pull-right[

<center>
<img src="images/purrr_map.png" height="300"/>
</center>

]

---

## Map sur plusieurs vecteurs/listes

Disons maintenant que nous voulions en plus spécifier une valeur d'écart-type différente pour chaque génération. Il faut spécifier un deuxième vecteur contenant les écart-types. Il faut alors utiliser la fonction `map2()`.

.pull-left[
```{r}
# Vecteur de moyennes
mu <- c(4, -1, 3)

# Vecteur d'écart-types
sigma <- c(1, 4, 7)

map2(mu, sigma, rnorm, n = 4)
```
]

.pull-right[

<center>
<img src="images/purrr_map2.png" height="300"/>
</center>

]

---

## Map sur plusieurs vecteurs/listes

Comme avec la fonction `map()`, il y a plusieurs variantes de `map2_*()`.

```{r}
map2(c(1, 2, 3), c(4, 5, 6), sum)

map2_dbl(c(1, 2, 3), c(4, 5, 6), sum) # Explicite sur la classe des valeurs de retour

map2_chr(c("a", "b", "c"), c("x", "y", "z"), ~paste(.x, .y, sep = "---"))

```

---

## Map sur plusieurs vecteurs/listes

Maintenant, comment faire pour *mapper* sur plus de deux vecteurs/listes? La fonction `pmap()` (*parallel map*) permet d'itérer simultanément sur plusieurs vecteurs/listes.

```{r, eval=FALSE}
pmap(.l, .f, ...)

map2(LIST_INPUT, FUNCTION_TO_APPLY, OPTIONAL_ARGUMENTS)
```

Trouver exemple:

```{r}
pmap_dbl(
  .l =
    list(
      c(1, 2, 3),
      c(4, 5, 6),
      c(7, 8, 9),
      c(10, 11, 12)
    ),
  .f = ~ ..1 + ..2 + ..3 / ..4 # Ex.: 1 + 7 + 7 / 10
)
```

---

class: inverse, center, middle

## Exercice pratique sur un cas réel

---

## Lire le contenu d'un répertoire

Une tâche courante consiste à lire plusieurs fichiers (CSV) dans un répertoire et de les combiner dans un seul *data frame*.

<center>
<img src="images/purrr_map_read_csv.svg.png" height="350"/>
</center>

<small>Inspiré de: https://www.gerkelab.com/blog/2018/09/import-directory-csv-purrr-readr/ </small>

---

## Lire le contenu d'un répertoire

<center>
<img src="images/purrr_map_read_csv2.svg.png" height="200"/>
</center>


---

## Étude de cas: *Capital bikeshare*

https://www.capitalbikeshare.com/

> Capital Bikeshare is metro DC's bikeshare service, with 4,300 bikes and 500+ stations across 6 jurisdictions: Washington, DC.; Arlington, VA; Alexandria, VA; Montgomery, MD; Prince George's County, MD; and Fairfax County, VA. Designed for quick trips with convenience in mind, it's a fun and affordable way to get around.

Similaire au système Bixi à Montréal.

<center>
<img src="http://www.parcjeandrapeau.com/medias/images/header/bixi-parc-jean-drapeau-montreal.jpg" height="300"/>
</center>

---

class: center
background-image: url("images/capital_bikeshare_map.png")

---

## Les données

Les statistiques sur l'utilisation des vélos pour l'année 2018 sont dans 12 fichiers différents (1 par mois).

https://s3.amazonaws.com/capitalbikeshare-data/index.html

- Plus de 3 500 000 lignes/observations (réduit de 90% pour les exercices suivants).

- Exemple pour le mois de janvier 2018.

```{r, echo=FALSE, message=FALSE}
read_csv("data/clean/capitale_bikeshare/201801_capitalbikeshare_tripdata.csv") %>% 
  arrange(start_date) %>% 
  glimpse()

```

---

## Les données

```{r, echo=FALSE, fig.height=4, fig.align='center'}

library(ggthemes)

# df <- read_csv("data/clean/capitale_bikeshare/201809-capitalbikeshare-tripdata.csv")

files <- list.files("data/clean/capitale_bikeshare/", full.names = TRUE)
df <- map_df(files, read_csv, col_types = cols())

df %>% 
  mutate(wday = lubridate::wday(start_date, label = TRUE)) %>% 
  filter(wday %in% c("Sun", "Sat")) %>% 
  mutate(month = lubridate::month(start_date, label = TRUE)) %>% 
  mutate(hour = lubridate::hour(start_date)) %>% 
  count(month, member_type) %>% 
  ggplot(aes(x = month, y = n, fill = member_type)) +
  geom_col() +
  xlab(NULL) +
  ylab("Nombre total de voyage") +
  # theme_solarized() +
  theme(legend.title = element_blank()) +
  labs(caption = "Data source: https://s3.amazonaws.com/capitalbikeshare-data/index.html") +
  labs(title = "Nombre de voyage par mois en 2018") +
  scale_fill_brewer(palette = "Set2")
```

---

## Les données

```{r, echo=FALSE, fig.height=4, fig.align='center'}
df <- read_csv("data/clean/capitale_bikeshare/201809-capitalbikeshare-tripdata.csv")

files <- list.files("data/clean/capitale_bikeshare/", full.names = TRUE)
df <- map_df(files, read_csv, col_types = cols())

df %>% 
  group_by(wday = lubridate::wday(start_date, label = TRUE)) %>% 
  summarise(mean_duration = mean(duration), sd_duration = sd(duration)) %>% 
  ggplot(aes(x = wday, y = mean_duration / 60)) +
  geom_col() +
  xlab(NULL) +
  ylab("Durée moyen de l'emprunt (minutes)") +
  labs(caption = "Data source: https://s3.amazonaws.com/capitalbikeshare-data/index.html") +
  labs(title = "Temps d'emprunt moyen par jour en 2018") 

```


---

class: inverse

## Exercice

.full-width[.content-box-gray[Utilisez la fonction `map_df()` pour lire et combiner tous les fichiers *captial bikeshare*.]]

```{r}
# Utiliser la fonction "list.files" pour lister tous les fichiers d'un répertoire
files <- list.files("data/clean/capitale_bikeshare/", full.names = TRUE)
files

# Completez avec votre code pour lire et combiner tous les fichiers

```

---

class: inverse

## Exercice

.full-width[.content-box-gray[Créez une fonction qui **(1)** ouvre chaque fichier et **(2)** qui calcule la moyenne de la variable/colonne `duration`.]]

```{r}
# Utiliser la fonction "list.files" pour lister tous les fichiers d'un répertoire
files <- list.files("data/clean/capitale_bikeshare/", full.names = TRUE)

# Completez avec votre code
```

---

## Note sur la lecture de fichiers

Je vous conseil fortement d'utiliser la fonction `read_csv()` de la librairie `readr` (inclut avec `tidyverse`) pour lire vos fichiers, car beaucoup plus rapide que `read.csv()`.

```{R, message=FALSE, echo=TRUE, fig.height=2.5, fig.width = 7, fig.align="center", cache=TRUE}
file <- "data/clean/capitale_bikeshare/201801_capitalbikeshare_tripdata.csv"

res <- microbenchmark::microbenchmark(
  read.csv = read.csv(file),
  read_csv =read_csv(file, col_type = cols()),
  fread = data.table::fread(file),
  times = 50
)

autoplot(res)

```


---

class: inverse, center, middle

# Peut-on aller plus loin?

## Programmation parallelle avec `furrr`

---

## Librairie `furrr`

```{r eval=FALSE, message=FALSE, warning=FALSE}
# Installer la librairie
install.packages("furrr")
```

- Le but de `furrr` est de simplifier la combinaison de la famille de fonctions de mappage de `purrr` et des capacités de traitement parallèle.

- Les fonctions de `furrr` débutent toutes par `future_*()` et peuvent remplacer pratiquement les utilisations de `map_*()`.

```{r, echo=FALSE}
library(furrr)
ls("package:furrr") %>% 
  .[grepl("^future_",.)] %>% 
  head(20)
```

---

## Parallelisation

```{r, message=FALSE}
library(furrr)
{{availableCores()}}

{{plan(multicore(workers = availableCores() - 1))}} # Utilise 7 coeurs

files <- list.files("data/clean/capitale_bikeshare/", full.names = TRUE)

df <- future_map_dfr(files, read_csv, col_types = cols())

glimpse(df)

```

---

class: inverse, center, middle

# Programmation fonctionnelle sur les *data frame*

---

## Programmation fonctionnelle sur les *data frame*

- Jusqu'à maintenant, à l'exception de `map_df()`, nous avons utilisé les fonctions `map_*()` qui retourne des vecteurs.

- Il existe également plusieurs fonctions pour utiliser l'approche fonctionnelle sur des *data frame*.

- La plupart des fonctions que nous verrons aujourd'hui proviennent de la librairie `dplyr`.

<center>
<img src="https://dplyr.tidyverse.org/logo.png" width="120"/>
</center>

- `dplyr` est inclut dans la librairie `tidyverse`.

```{r, eval=FALSE}
library(tidyverse)
```

---

## Retour sur l'exercice précédent

Dans un exercice précédent, nous devions calculer la moyenne de la colonne `duration` pour chaque mois de 2018. Disons maintenant que nous voulons calculer la moyenne de toutes les colonnes numériques.

```{r, message=FALSE}
files <- list.files("data/clean/capitale_bikeshare/", full.names = TRUE)

calculate_mean <- function(file) {
  df <- read_csv(file) # Ouvrir le fichier

  l <- list(
    mean_duration = mean(df$duration),
    mean_start_station_number = mean(df$start_station_number),
    mean_end_station_number = mean(df$end_station_number)
  )

  return(l)
}

```

---

## Retour sur l'exercice précédent

```{r, message=FALSE}
res <- map(files, calculate_mean)
head(res, 1)
```


**Cette approche fonctionne bien, mais:**

1. Il est impossible de savoir à quel mois correspond chacune des valeurs du vecteur.
2. Le code devra être modifié si une nouvelle colonne numérique est ajoutée dans les fichiers csv.

---

## La fonction `summarise()`

- La fonction `summarise()` permet de *compresser* un *data frame* en lui **appliquant une fonction** qui réduit le nombre d'observations.
- Par exemple, on peut calculer la valeur moyenne de `duration` pour les données de janvier 2018.

```{r, message = FALSE}
df <- read_csv("data/clean/capitale_bikeshare/201801_capitalbikeshare_tripdata.csv")

{{summarise(df, mean_duration = mean(duration))}}
```

---

## La fonction `summarise_if()`

- La fonction `summarise_if()` est une variante de `summarise()` qui permet d'appliquer une fonction à un ensemble de colonnes qui répondent à une ou des condition(s).

- La fonction `summarise_if()` s'utilise comme suit:

```{r, eval = FALSE}
summarise_if(.tbl, .predicate, .funs, ...)
```

Où:

- `.tbl` est un *data frame*.

- `.predicate` une fonction qui retourne `TRUE/FALSE`.

- `.funs` une liste de fonctions à appliquer.

---

## La fonction `summarise_if()`

On peux maintenant utilise la fonction `summarise_if()` sur nos données.

```{r}
df <- read_csv("data/clean/capitale_bikeshare/201801_capitalbikeshare_tripdata.csv")

# On applique la fonction "mean" à toutes les colonnes de type "numeric" du data frame "df"
summarise_if(.tbl = df, .predicate = is.numeric, .funs = mean)
```

--

Ne célébrons pas trop vite! N'oubliez pas qu'on voulait faire ce calcule pour chacun des mois de l'année 2018.

<center>
<image src="https://media.giphy.com/media/OWJILXs8QpyiA/giphy.gif" height="200" frameBorder="0" class="giphy-embed" allowFullScreen></image>
</center>

---

## La fonction `group_by()`

- La fonction `group_by()` peut s'utiliser conjointement avec la fonction `summarise()` pour appliquer un calcule à un ensemble de groupes dans un *data frame*.

- - La fonction `group_by()` **prépare** un *data frame* a être utilisé par la fonction `summarise()`.

- La fonction `group_by()` s'utilise comme suit:

```{r, eval = FALSE}
group_by(.data, ...)
```

Où:

- `.data` est un *data frame*.

- `...` est une liste de colonne à utiliser pour effectuer le regroupement.

---

## La fonction `group_by()`

Par exemple, grouper `mtcars` sur la base de la colonne `cyl` (nombre de cylindres).  Le résultat renvoyé nous indique qu'il y a trois groupes de `cyl` dans le *data frame*.

```{r}
group_by(mtcars, cyl)
```

---

## Calculer les moyennes mensuelles

Calculer **les moyennes mensuelles** de toutes les colonnes numériques, en utilisant toutes les données de *bikeshare*. On peut diviser ce problème en trois étapes:

1. Lire tous les fichiers.
2. Grouper les données par mois.
3. Calculer la moyenne de chacune des colonnes de type numérique.

---

## Calculer les moyennes mensuelles

```{r}
# Étape 1: Lire tous les fichiers
files <- list.files("data/clean/capitale_bikeshare/", full.names = TRUE)
df <- map_df(files, read_csv)

# Ajouter la colonne mois dans le data frame
df$month <- format(df$start_date, "%b")

# Étape 2: Grouper les données par mois.
df <- group_by(df, month)

# Étape 3: Calculer la moyenne de chacune des colonnes de type numérique.
df <- summarise_if(.tbl = df, .predicate = is.numeric, .funs = mean)

head(df) # Afficher les 6 premières lignes
```

---

## L'opérateur pipe ` %>% `

L'opérateur pipe, `%>%`, permet d'enchaîner les opérations en passant le résultat d'un fonction comme premier argument dans la fonction suivante. Lorsque vous voyez `%>%`, vous devriez vous vous dire **ensuite**. Ce qui est très utile lorsqu'on a pas besoin des résultats intermédiaires.

<center><img src="https://magrittr.tidyverse.org/logo.png" width="200"/></center>

---

## L'opérateur pipe ` %>% `

```{r}
3 %>% log()
log(3)

```

Par défaut, ` %>% ` passe le paramètre à la première position de la fonction suivante. On peut cependant contrôler ce comportement en utilisant le point `.` pour explicitement spécifier où doit aller le paramètre.

```{r}
set.seed(1234)

2 %>% rnorm(n = 10, mean = .)
rnorm(n = 10, mean = 2)
```


---

## La version compacte

```{r}
files <- list.files("data/clean/capitale_bikeshare/", full.names = TRUE)

files %>% 
  map_df(read_csv) %>% 
  group_by(month = lubridate::month(start_date, label = TRUE)) %>% 
  summarise_if(is.numeric, mean)
```

---

<center>
<image src="https://media.giphy.com/media/iI6eeGjwScTCM/giphy.gif" height="200" frameBorder="0" class="giphy-embed" allowFullScreen></image>
</center>

---

class: inverse

## À vous de jouer!

.full-width[.content-box-gray[Utiliser les concepts vu aujourd'hui pour reproduire le graphique suivant. Il s'agit de calculer la moyenne de la variable `duration` par jour et ce pour chaque mois de l'année.]]

```{r, echo=FALSE, fig.width=5, fig.height=3, fig.align='center'}
files <- list.files("data/clean/capitale_bikeshare/", full.names = TRUE)

df <- files %>% 
  map_df(read_csv) %>% 
  group_by(month = lubridate::month(start_date, label = TRUE), hour = lubridate::hour(start_date)) %>% 
  summarise(mean_duration = mean(duration))

df %>% 
  ggplot(aes(x = hour, y = mean_duration / 60, color = factor(month))) +
  geom_line() +
  xlab("Heure de la journée") +
  ylab("Emprunt moyen (minutes)") +
  guides(color = guide_legend(ncol = 2)) +
  labs(color = NULL)

```

---

## La fonction `nest()`

La fonction `nest()` permet de créer une liste de *data frame* à l'intérieur d'un *data frame*. Cette fonction est généralement utilisée conjointement avec `group_by()`.

```{r}
head(mtcars)

mtcars %>% 
  group_by(cyl) %>% # Grouper selon la variable "cyl"
  nest() # "Compresser" le data frame, par défault, la nouvelle colonne se nomme "data"
```

---

## La fonction `unnest()`

La fonction `unnest()` de décompresser un *data frame* qui a été compressé avec `nest()`.

```{r}
mtcars %>% 
  group_by(cyl) %>% # Grouper selon la variable "cyl"
  nest() %>% # "Compresser" le data frame, par défault, la nouvelle colonne se nomme "data"
  unnest()
```

---

## La fonction `nest()`

En combinant les fonctions `nest()` et `map()`, il est possible de rapidement créer un modèle linéraire pour chacun des groupes.

```{r}
mtcars %>% 
  group_by(cyl) %>% 
  nest() %>% 
  mutate(mod = map(data, ~lm(mpg ~ wt, data = .))) #<<
```

La *data frame* contient maintenant:

- La ou les variables de regroupement.
- Les données compressées (colonne `data`).
- Les modèles linéraires (colonne `mod`).

**Les risques d'erreurs sont de beaucoup diminués, car tout est encapsulé dans un *data frame*.**

---

## La librairie `broom`

La librairie `broom` permet de convertir des objets statistiques en *data frame*.

```{r}
mtcars %>% 
  group_by(cyl) %>% 
  nest() %>% 
  mutate(mod = map(data, ~lm(mpg ~ wt, data = .))) %>% 
  mutate(coef = map(mod, broom::tidy)) %>% #<<
  unnest(coef)
```

---

class: inverse

## À vous de jouer!

.full-width[.content-box-gray[En utilisant le jeu de données `cars`, créer un modèle linéraire multiple (`mpg ~ horsepower + weight`) pour les `model` de chaque année. Par la suite, ajouter une colonne dans le *data frame* qui contient le R2 de la régression.]]

```{r}
cars <- read_csv("data/clean/cars.csv")
cars
```

---

## Les données

```{r, fig.align="center", echo=FALSE, warning=FALSE, fig.height=5}
cars %>% 
  ggplot(aes(x = horsepower, y = mpg)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~model, scales = "free")
```


```{r, echo=FALSE, eval=FALSE}
select_if(cars, is.numeric) %>% 
  languageR::pairscor.fnc()

cars %>% 
  group_by(model) %>% 
  nest() %>% 
  mutate(mod = map(data, ~lm(mpg ~ horsepower + weight, data = .))) %>% 
  mutate(summary = map(mod, summary)) %>% 
  mutate(r2 = map_dbl(r2, "r.squared"))
```

---

## Conclusions

- R est un langage de programmation fonctionnelle qui permet de faire beaucoup de chose rapidement et de manière élégante.

- La programmation fonctionnelle permet de diminuer les chances d'erreurs dans le code.
  - Si erreur, plus facilement corrigable, car on modifie à un seul endroit.
  
- La librairie `purrr` offre un ensemble d'outils qui permet d'appliquer efficacement plusieurs concepts de la programmation fonctionnelle.

- L'utilisation de `nest()` permet d'encapsuler les résultats dans un *data frame* ce qui permet de les faire suivre tout au long du processus d'analyse.

---

## Merci!

Merci au comité organisateur de R à Québec 2019!

<center>
<image src="images/comite.bmp" height="300", align="middle"</image><image src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/R_logo.svg/724px-R_logo.svg.png" height="100", align="middle"</image><image src="images/logo_r_a_quebec_2019.png" height="100", align="middle"</image>
</center>

---

## Références

Beaucoup de matériel présenté dans cette classe provient de ressources en ligne. Merci à tout ceux et celles à qui j'ai piqué du code!!!

- https://bit.ly/2wjB8IB
- https://adv-r.hadley.nz/functionals.html#map
- https://www.r-exercises.com/2018/01/12/functional-programming-with-purrr-exercises-part-1/
- https://jennybc.github.io/purrr-tutorial/ls03_map-function-syntax.html
- https://sebastiansauer.github.io/multiple-lm-purrr2/
- https://nicercode.github.io/intro/repeating-things.html
- https://www.earthdatascience.org/courses/earth-analytics/automate-science-workflows/write-efficient-code-for-science-r/